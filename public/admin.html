
<!doctype html>
<html lang="de">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Admin â€“ 3. KÃ¶nigsbrunner Mini-FuÃŸball Hallenmasters</title>

  <style>
    :root {
      --bg: #0f172a; --fg: #e5e7eb; --muted: #9ca3af; --accent: #22c55e; --danger: #ef4444;
      --card: #111827; --border: #1f2937;

      /* Gruppenfarben */
      --grpA-bg: #0b1b3a; --grpA-fg: #bfdbfe; --grpA-br: #1d4ed8;
      --grpB-bg: #2b0c0c; --grpB-fg: #fecaca; --grpB-br: #7f1d1d;
      --grpC-bg: #052e1b; --grpC-fg: #86efac; --grpC-br: #166534;
      --grpD-bg: #1f2937; --grpD-fg: #fde68a; --grpD-br: #f59e0b;
      --grpE-bg: #1f2937; --grpE-fg: #ddd6fe; --grpE-br: #8b5cf6;
      --grpF-bg: #0b3640; --grpF-fg: #c0fafe; --grpF-br: #06b6d4;

      --ok:#22c55e; --warn:#f59e0b; --err:#ef4444;
      --hint-bg:#0b1020; --hint-br:#2a3b57; --hint-fg:#cbd5e1;
    }

    html, body { height:100%; }
    body { margin:0; background:var(--bg); color:var(--fg);
           font-family:system-ui,-apple-system, Segoe UI, Roboto, Ubuntu, Arial; }

    header { position: sticky; top: 0; z-index: 8; background: var(--card); border-bottom: 1px solid var(--border); }
    header .bar { display:flex; align-items:center; justify-content:space-between; padding: .75rem 1rem; gap: 1rem; }
    .leftWrap { display:flex; align-items:center; gap:1rem; flex-wrap:wrap; min-height:56px; }
    .titleWrap { display:flex; align-items:center; gap:.75rem; }
    .clubLogo { width:56px; height:56px; object-fit:contain; border-radius:6px; background:#0b1020; border:1px solid var(--border); }
    header h1 { margin:0; font-size:1.25rem; }

    .viewerLink { color: var(--muted); text-decoration: none; }

    #qrImageHeader { width:256px; height:256px; background:#fff; padding:12px; border:1px solid var(--border);
      border-radius:4px; display:flex; align-items:center; justify-content:center; box-sizing:content-box; }

    .logoPath{
      display:inline-flex; align-items:center; gap:.35rem;
      background:var(--hint-bg); color:var(--hint-fg);
      border:1px dashed var(--hint-br); border-radius:8px;
      padding:.2rem .5rem; font-size:.85rem;
    }
    .logoError{
      display:none; margin-left:.5rem;
      color:#fecaca; background:#1b0f12; border:1px solid #7f1d1d;
      padding:.2rem .5rem; border-radius:6px; font-size:.85rem;
    }

    main { padding:1rem; max-width:1200px; margin:0 auto; }
    section { margin-bottom:2rem; background:var(--card); border:1px solid var(--border); border-radius:8px; }
    section > header { position: static; z-index: auto; align-items:center; justify-content:space-between; gap:1rem; padding:.75rem 1rem; border-bottom:1px solid var(--border); display:flex; }
    .row { display:flex; flex-wrap:wrap; gap:.75rem; align-items:center; }
    .tableWrap { overflow-x:auto; }

    .btn { cursor:pointer; border:1px solid var(--border); background:#0b1020; color:#e5e7eb; padding:.5rem .75rem; border-radius:6px; font-weight:600; }
    .btn:hover { filter:brightness(1.08); }
    .btn-primary { border-color:#1d4ed8; background:#0b1b3a; color:#bfdbfe; }
    .btn-success { border-color:#166534; background:#052e1b; color:#86efac; }
    .btn-danger  { border-color:#7f1d1d; background:#2b0c0c; color:#fecaca; }
    .btn-muted   { border-color:var(--border); background:#0b1020; color:#9ca3af; }

    .btn.grpA { border-color:var(--grpA-br); background:var(--grpA-bg); color:var(--grpA-fg); }
    .btn.grpB { border-color:var(--grpB-br); background:var(--grpB-bg); color:var(--grpB-fg); }
    .btn.grpC { border-color:var(--grpC-br); background:var(--grpC-bg); color:var(--grpC-fg); }
    .btn.grpD { border-color:var(--grpD-br); background:var(--grpD-bg); color:var(--grpD-fg); }
    .btn.grpE { border-color:var(--grpE-br); background:var(--grpE-bg); color:var(--grpE-fg); }
    .btn.grpF { border-color:var(--grpF-br); background:var(--grpF-bg); color:var(--grpF-fg); }

    .input, select { background:#0b1020; color:var(--fg); border:1px solid var(--border); border-radius:6px; padding:.45rem .6rem; min-height:2rem; }

    table { width:100%; border-collapse:collapse; }
    th, td { border-bottom:1px solid var(--border); padding:.5rem; text-align:left; }
    th { color:#cbd5e1; font-weight:700; background:#0b1020; }
    tr:hover td { background:#0a0f1f; }

    .pill { display:inline-block; padding:.15rem .5rem; border-radius:999px; border:1px solid var(--border); font-size:.8rem; color:#9ca3af; }
    .pill.grpA { color:var(--grpA-fg); border-color:var(--grpA-br); background:var(--grpA-bg); }
    .pill.grpB { color:var(--grpB-fg); border-color:var(--grpB-br); background:var(--grpB-bg); }
    .pill.grpC { color:var(--grpC-fg); border-color:var(--grpC-br); background:var(--grpC-bg); }
    .pill.grpD { color:var(--grpD-fg); border-color:var(--grpD-br); background:var(--grpD-bg); }
    .pill.grpE { color:var(--grpE-fg); border-color:var(--grpE-br); background:var(--grpE-bg); }
    .pill.grpF { color:var(--grpF-fg); border-color:var(--grpF-br); background:var(--grpF-bg); }

    tr.grpA td { background:rgba(29,78,216,.08); }
    tr.grpB td { background:rgba(220,38,38,.08); }
    tr.grpC td { background:rgba(22,163,74,.08); }

    .teams-grid{ display: grid; grid-template-columns: repeat(3, minmax(320px, 1fr)); gap: 16px; align-items: start; padding: 1rem; }
    @media (max-width: 1100px){ .teams-grid{ grid-template-columns: repeat(2, minmax(320px, 1fr)); } }
    @media (max-width: 720px){ .teams-grid{ grid-template-columns: 1fr; } }
    .card { background: var(--card); border: 1px solid var(--border); border-radius:8px; padding: 12px; }
    .table-wrap { overflow:auto; }
    .table-wrap thead th { background:#0b1020; }

    .tm-row { display:flex; gap:.5rem; flex-wrap:wrap; align-items:center; }
    .tm-row label { color:#cbd5e1; font-size:.85rem; }
    .tm-row .input { min-width: 120px; }

    .winIcon { font-size: 1rem; margin-right: .35rem; vertical-align: middle; }
    .winnerText { color: var(--accent); font-weight: 600; }
    .loserText  { color: var(--muted); }
    .teamNameWrap { display:inline-flex; align-items:center; gap:.35rem; }
  </style>
</head>
<body>
  <header>
    <div class="bar">
      <div class="leftWrap">
        <div class="titleWrap">
          <img class="clubLogo" id="clubLogo" alt="Vereinslogo" />
          <div style="display:flex; flex-direction:column; gap:.25rem;">
            <h1>Admin â€“ 3. KÃ¶nigsbrunner Mini-FuÃŸball Hallenmasters</h1>
            <div class="logoPath">
              Logo-Pfad: <code id="logoPathText">â€“</code>
              <span id="logoError" class="logoError">Logo konnte nicht geladen werden. Datei unter <code>public/assets/â€¦</code> ablegen und Pfad prÃ¼fen.</span>
            </div>
          </div>
        </div>

        <div class="row" style="gap:.5rem;">
          <label for="qrBase" class="pill" title="Protokoll+Host+Port (z.â€¯B. 192.168.0.25)">Viewerâ€‘Basis:</label>
          <input id="qrBase" type="text" class="input" style="min-width:260px;" placeholder="192.168.0.25" />
          <button id="btnSaveQRBase" type="button" class="btn btn-primary">Speichern</button>
          <a id="viewerLink" class="viewerLink" target="_blank" rel="noopener">Viewer Ã¶ffnen</a>
        </div>
      </div>

      <div id="headerQR" style="display:flex; flex-direction:column; align-items:flex-end;">
        <div class="container">
          <img src="" id="qr-img" alt="QR-Code zum Viewer">
        </div>
      </div>
    </div>
  </header>

  <main>
    <!-- Teams -->
    <section id="teamsSection">
      <header>
        <h2>Teams</h2>
        <div class="row">
          <button id="btnLoadTeams" type="button" class="btn btn-muted">Teams laden</button>
          <button id="btnDeleteAllTeams" type="button" class="btn btn-danger">Alle Teams lÃ¶schen</button>
        </div>
      </header>

      <div class="teams-grid" id="teamsGrid"></div>

      <div class="row" style="padding:1rem">
        <div class="row" style="flex:1 1 100%">
          <input id="teamName" class="input" placeholder="Teamname" />
          <select id="teamGroup" class="input">
            <option value="A">Gruppe A</option>
            <option value="B">Gruppe B</option>
            <option value="C">Gruppe C</option>
          </select>
          <button id="btnAddTeam" type="button" class="btn btn-success">HinzufÃ¼gen</button>
          <span id="teamsMsg" class="pill" style="display:none"></span>
        </div>

        <div class="row" style="flex:1 1 100%">
          <input id="teamsFile" type="file" accept=".csv,.json" class="input" />
          <button id="btnImportTeams" type="button" class="btn btn-primary">Teams aus Datei importieren</button>
          <span id="importMsg" class="pill" style="display:none"></span>
        </div>
      </div>
    </section>

    <!-- Matches (Haupt-View) -->
    <section id="matchesSection">
      <header>
        <h2>Spiele</h2>
        <div class="row">
          <button id="btnLoadMatches" type="button" class="btn btn-muted">Spiele laden</button>
          <button id="btnStartA" type="button" class="btn grpA">Gruppe A starten</button>
          <button id="btnStartB" type="button" class="btn grpB">Gruppe B starten</button>
          <button id="btnStartC" type="button" class="btn grpC">Gruppe C starten</button>
          <button id="btnNextRound" type="button" class="btn btn-primary">NÃ¤chste Runde (oberste 3)</button>
          <span id="nextMsg" class="pill" style="display:none"></span>
          <button id="btnReset"  type="button" class="btn btn-danger">Spielplan zurÃ¼cksetzen</button>
          <button id="btnReseedGroups" type="button" class="btn btn-primary">Gruppen neu zusammenstellen (nach 3 Runden)</button>
          <span id="reseedMsg" class="pill" style="display:none"></span>
        </div>
      </header>

      <div class="row" style="padding:1rem">
        <div class="card" style="flex:1 1 100%">
          <h3 style="margin:.25rem 0 1rem; color:#cbd5e1;">Zeitmanagement (global)</h3>
          <div class="tm-row">
            <label for="sched-time">Start:</label>
            <input id="sched-time" type="time" class="input" step="60" />
            <label for="sched-dur">Dauer (min):</label>
            <input id="sched-dur" type="number" min="1" step="1" value="10" class="input" style="width:90px" />
            <label for="sched-break">Pause (min):</label>
            <input id="sched-break" type="number" min="0" step="1" value="2" class="input" style="width:90px" />
            <button id="sched-save" class="btn btn-primary">Speichern</button>
            <span id="timeMsg" class="pill" style="display:none; margin-left:auto;"></span>
          </div>
          <div style="margin-top:.5rem; color:#9ca3af; font-size:.85rem;">
            Raster: alphabetisch pro Slot (A â†’ B â†’ C). Runde&nbsp;2 von A bezieht sich zeitlich auf vorheriges C. Slot = <em>Dauer + Pause</em>.
          </div>
        </div>
      </div>

      <div class="tableWrap" style="padding:1rem">
        <table id="matchesTable">
          <thead>
            <tr>
              <th>ID</th>
              <th>Gruppe</th>
              <th>Runde</th>
              <th>Feld</th>
              <th>Zeit</th>
              <th>Team A</th>
              <th>Team B</th>
              <th>Sieger</th>
              <th>Aktion</th>
            </tr>
          </thead>
          <tbody></tbody>
        </table>
      </div>
    </section>

    <!-- Historie (separater View) -->
    <section id="historySection">
      <header>
        <h2>Historie (letzte gespielte Runde)</h2>
        <div class="row">
          <label for="hist-group" class="pill">Gruppe:</label>
          <select id="hist-group" class="input">
            <option value="A">A</option><option value="B">B</option><option value="C">C</option>
            <option value="D">D</option><option value="E">E</option><option value="F">F</option>
          </select>
          <button id="btnLoadHistory" type="button" class="btn btn-muted">History laden</button>
          <button id="btnApplyHistory" type="button" class="btn btn-primary" title="Korrekturen anwenden und aktuellen 3er-Block im Haupt-View aktualisieren">Ãœbernehmen & Hauptâ€‘View aktualisieren</button>
          <span id="histMsg" class="pill" style="display:none"></span>
        </div>
      </header>

      <div class="tableWrap" style="padding:1rem">
        <table id="historyTable">
          <thead>
            <tr>
              <th>#</th>
              <th>GruppeÂ·Runde</th>
              <th>Feld</th>
              <th>Team A</th>
              <th>Team B</th>
              <th>Sieger</th>
              <th>Aktion</th>
            </tr>
          </thead>
          <tbody></tbody>
        </table>
      </div>
    </section>
  </main>

  <!-- Socket.IO -->
  <script src="/socket.io/socket.io.js"></script>
  <!-- QR helper -->
  <script src="qr_script.js"></script>

  <!-- Logo -->
  <script>
    const LOGO_PATH = '/assets/Fussballwappen_logo.png';
    const cacheBust = () => `?_v=${Date.now()}`;

    function setLogo(){
      const img = document.getElementById('clubLogo');
      const pathEl = document.getElementById('logoPathText');
      const errEl  = document.getElementById('logoError');

      if (!img || !pathEl) return;
      const url = LOGO_PATH + cacheBust();
      pathEl.textContent = LOGO_PATH;

      img.onload = () => { if (errEl) errEl.style.display = 'none'; };
      img.onerror = () => { if (errEl) errEl.style.display = 'inline-flex'; };
      img.src = url;
    }

    function initHeader(){ setLogo(); }
  </script>

  <!-- ===== API / State / Helpers ===== -->
  <script>
    const API_BASE = window.location.origin + '/api';

    async function safeFetch(path, init) {
      const url = API_BASE + path;
      const res = await fetch(url, init);
      if (!res.ok) {
        let text = ''; try { text = await res.text(); } catch {}
        throw new Error('HTTP ' + res.status + ' ' + res.statusText + (text ? ': ' + text : ''));
      }
      return res.json();
    }

    /* === API Wrapper === */
    const apiTeamsList      = () => safeFetch('/teams', { method:'GET' });
    const apiTeamsDeleteAll = () => safeFetch('/teams', { method:'DELETE' });
    const apiTeamAdd        = (name, groupName) => safeFetch('/teams', { method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify({ name, groupName }) });
    const apiTeamDelete     = (id) => safeFetch('/teams/' + encodeURIComponent(id), { method:'DELETE' });

    const apiMatchesList    = () => safeFetch('/matches', { method:'GET' });
    const apiGroupStart     = async (group) => {
      const schedule = getSchedule();
      if (!schedule) throw new Error('Kein gÃ¼ltiger Zeitplan konfiguriert.');
      return safeFetch('/matches/start/' + encodeURIComponent(group), {
        method:'POST',
        headers:{'Content-Type':'application/json'},
        body: JSON.stringify({ schedule })
      });
    };
    const apiMatchesReset   = () => safeFetch('/matches/reset', { method:'DELETE' });

    const apiWinnerSet      = (matchId, winnerTeamId) => safeFetch('/results/winner', { method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify({ matchId, winner: winnerTeamId }) });

    const apiNextRound      = async (groupName, results) => {
      const schedule = getSchedule();
      if (!schedule) throw new Error('Kein gÃ¼ltiger Zeitplan konfiguriert.');
      return safeFetch('/funino/nextRound', {
        method:'POST',
        headers:{'Content-Type':'application/json'},
        body: JSON.stringify({ groupName, results, schedule })
      });
    };

    const apiScheduleRecalc = (schedule) =>
      safeFetch('/schedule/recalculate', {
        method:'POST',
        headers:{'Content-Type':'application/json'},
        body: JSON.stringify({ schedule })
      });

    const apiReseedGroups = (schedule) =>
      safeFetch('/funino/reseedGroups', {
        method: 'POST',
        headers: { 'Content-Type':'application/json' },
        body: JSON.stringify({ schedule })
      });

    /* === History APIs === */
    const apiHistoryLatest     = (group) => safeFetch('/history/latest/' + encodeURIComponent(group), { method:'GET' });
    const apiHistorySetWinner  = (historyId, winner) => safeFetch('/history/' + encodeURIComponent(historyId) + '/winner', {
      method:'PATCH',
      headers:{'Content-Type':'application/json'},
      body: JSON.stringify({ winner })
    });
    const apiRebuildCurrRound  = (group) => safeFetch('/funino/rebuildCurrentRound', {
      method:'POST',
      headers:{'Content-Type':'application/json'},
      body: JSON.stringify({ groupName: group })
    });

    /* === Aliases fÃ¼r UI === */
    const loadTeams      = apiTeamsList;
    const deleteAllTeams = apiTeamsDeleteAll;
    const addTeam        = apiTeamAdd;
    const deleteTeam     = apiTeamDelete;

    const loadMatches    = apiMatchesList;
    const startGroup     = apiGroupStart;
    const resetMatches   = apiMatchesReset;

    const setWinner      = apiWinnerSet;
    const nextRoundReq   = apiNextRound;

    // History
    const loadHistoryLatest = apiHistoryLatest;
    const setHistoryWinner  = apiHistorySetWinner;
    const rebuildCurrentRound = apiRebuildCurrRound;

    /* === State === */
    let TEAMS = [];
    let MATCHES = [];
    let HISTORY = { groupName:null, round:null, batchId:null, items:[] };

    /* === Helpers & Messages === */
    function groupClass(g){
      const x = String(g || '').trim().toUpperCase();
      switch (x) {
        case 'A': return 'grpA';
        case 'B': return 'grpB';
        case 'C': return 'grpC';
        case 'D': return 'grpD';
        case 'E': return 'grpE';
        case 'F': return 'grpF';
        default:  return '';
      }
    }

    function showMsg(selector, text, isError){
      const el = typeof selector==='string' ? document.querySelector(selector) : selector;
      if(!el) return;
      el.textContent = text; el.style.display='inline-block';
      el.style.borderColor = isError ? 'var(--danger)' : 'var(--accent)';
      el.style.color = isError ? '#fecaca' : '#86efac';
      clearTimeout(el._t); el._t = setTimeout(() => { el.style.display='none'; }, 3000);
    }
  </script>

  <!-- ===== Zeitmanagement (v2) ===== -->
  <script>
    const SCHED_KEY = 'admin.schedule.v2'; // { timeHHMM, dur, brk }

    function loadSchedule(){
      try { return JSON.parse(localStorage.getItem(SCHED_KEY) || 'null'); }
      catch { return null; }
    }
    function saveSchedule(cfg){ localStorage.setItem(SCHED_KEY, JSON.stringify(cfg)); }
    function getSchedule(){
      const s = loadSchedule();
      if(!s) return null;
      if(!/^\d{2}:\d{2}$/.test(s.timeHHMM)) return null;
      if(!Number.isFinite(s.dur) || s.dur <= 0) return null;
      if(!Number.isFinite(s.brk) || s.brk < 0) return null;
      return s;
    }

    function fillScheduleUI(){
      const cfg = loadSchedule() || {};
      const time = document.getElementById('sched-time');
      const dur  = document.getElementById('sched-dur');
      const brk  = document.getElementById('sched-break');
      if (time && cfg.timeHHMM) time.value = cfg.timeHHMM;
      if (dur  && Number.isFinite(cfg.dur)) dur.value = cfg.dur;
      if (brk  && Number.isFinite(cfg.brk)) brk.value = cfg.brk;
    }
    function wireScheduleUI(){
      const btn = document.getElementById('sched-save');
      btn && btn.addEventListener('click', async () => {
        const timeHHMM = document.getElementById('sched-time').value;
        const dur   = Number(document.getElementById('sched-dur').value);
        const brk   = Number(document.getElementById('sched-break').value);
        if (!/^\d{2}:\d{2}$/.test(timeHHMM)) { showMsg('#timeMsg', 'Bitte Startzeit im Format HH:MM setzen.', true); return; }
        if (!Number.isFinite(dur) || dur <= 0) { showMsg('#timeMsg', 'Dauer (min) ungÃ¼ltig.', true); return; }
        if (!Number.isFinite(brk) || brk < 0) { showMsg('#timeMsg', 'Pause (min) ungÃ¼ltig.', true); return; }

        const schedule = { timeHHMM, dur, brk };
        saveSchedule(schedule);
        showMsg('#timeMsg', 'Zeitplan gespeichert. Berechne Zeiten ...');

        try {
          await apiScheduleRecalc(schedule);
          await refreshMatches();
          showMsg('#timeMsg', 'Zeiten aktualisiert.');
        } catch(e) {
          showMsg('#timeMsg', 'Recalc-Fehler: ' + e.message, true);
        }
      });
    }
  </script>

  <!-- ===== Teams: je Gruppe eigene Tabelle ===== -->
  <script>
    function buildTeamsGrid(groups){
      const grid = document.getElementById('teamsGrid');
      grid.innerHTML = '';
      const order = ['A','B','C','D','E','F'];
      const groupsOrdered = groups.slice().sort((a,b)=> order.indexOf(a) - order.indexOf(b));

      groupsOrdered.forEach(g => {
        const card = document.createElement('div'); card.className = 'card';
        const badge = document.createElement('span'); badge.className = 'pill ' + groupClass(g);
        badge.textContent = 'Gruppe ' + g; badge.style.marginBottom = '.5rem'; card.appendChild(badge);

        const wrap = document.createElement('div'); wrap.className = 'table-wrap';
        const table = document.createElement('table'); table.id = `teams-table-${g}`;
        const thead = document.createElement('thead'); thead.innerHTML = `
          <tr>
            <th style="width:80px;">ID</th>
            <th>Name</th>
            <th style="width:160px;">Aktion</th>
          </tr>`;
        table.appendChild(thead);
        const tbody = document.createElement('tbody'); tbody.id = `teams-tbody-${g}`; table.appendChild(tbody);
        wrap.appendChild(table); card.appendChild(wrap); grid.appendChild(card);
      });

      document.querySelectorAll('[id^="teams-table-"]').forEach(tbl => {
        tbl.addEventListener('click', async (e) => {
          const btn = e.target.closest('button'); if(!btn) return;
          const action = btn.dataset.action; const id = btn.dataset.id;
          if(action === 'delete'){
            try { await deleteTeam(id); await refreshTeams(); }
            catch (err) { showMsg('#teamsMsg', 'Fehler beim LÃ¶schen: ' + err.message, true); }
          }
        });
      });
    }

    function renderTeams(){
      const groupsSet = new Set(TEAMS.map(t => String(t.groupName || '').trim().toUpperCase()).filter(Boolean));
      const groups = groupsSet.size ? Array.from(groupsSet) : ['A','B','C'];
      buildTeamsGrid(groups);

      groups.forEach(g => { const tbody = document.getElementById(`teams-tbody-${g}`); if (tbody) tbody.innerHTML = ''; });
      TEAMS.forEach(t => {
        const g = String(t.groupName || '').trim().toUpperCase();
        const tbody = document.getElementById(`teams-tbody-${g}`); if (!tbody) return;

        const tr = document.createElement('tr');
        const cls = groupClass(t.groupName);
        if (cls) tr.classList.add(cls);

        const tdId = document.createElement('td'); tdId.textContent = t.id ?? '';
        const tdName = document.createElement('td'); tdName.textContent = t.name ?? '';
        const tdAction = document.createElement('td');
        const btnDel = document.createElement('button');
        btnDel.className='btn btn-danger'; btnDel.type='button';
        btnDel.dataset.action='delete'; btnDel.dataset.id=String(t.id);
        btnDel.textContent='LÃ¶schen';
        tdAction.appendChild(btnDel);

        tr.appendChild(tdId);
        tr.appendChild(tdName);
        tr.appendChild(tdAction);

        tbody.appendChild(tr);
      });
    }

    async function refreshTeams(){
      try { TEAMS = await loadTeams(); renderTeams(); }
      catch(e){ showMsg('#teamsMsg', 'Fehler: '+e.message, true); }
    }
  </script>

  <!-- ===== Matches: Rendering ===== -->
  <script>
    function renderMatches() {
      const tbody = document.querySelector('#matchesTable tbody');
      if (!tbody) return;
      tbody.innerHTML = '';

      if (!Array.isArray(MATCHES)) {
        showMsg('#nextMsg', 'Spieldaten ungÃ¼ltig (kein Array).', true);
        return;
      }

      MATCHES.forEach(m => {
        const tr = document.createElement('tr');
        const cls = groupClass(m.groupName);
        if (cls) tr.classList.add(cls);

        const id        = m?.id ?? '';
        const groupName = m?.groupName ?? '';
        const round     = m?.round ?? '';
        const field     = m?.field ?? '';
        const teamAId   = m?.teamA_id ?? null;
        const teamBId   = m?.teamB_id ?? null;
        const teamAName = m?.teamA ?? (teamAId != null ? String(teamAId) : '');
        const teamBName = m?.teamB ?? (teamBId != null ? String(teamBId) : '');
        const planned   = m?.plannedStart ?? 'â€“';
        const winnerVal = m && typeof m.winner !== 'undefined' ? m.winner : null;
        const hasWinner = winnerVal !== null && winnerVal !== undefined;

        const tdId    = document.createElement('td'); tdId.textContent = id;

        const tdGroup = document.createElement('td');
        const badge   = document.createElement('span');
        badge.className = 'pill ' + groupClass(groupName);
        badge.textContent = groupName;
        tdGroup.appendChild(badge);

        const tdRound = document.createElement('td'); tdRound.textContent = round;
        const tdField = document.createElement('td'); tdField.textContent = field;
        const tdTime  = document.createElement('td'); tdTime.textContent = planned;

        const isWinA = hasWinner && Number(winnerVal) === Number(teamAId);
        const isWinB = hasWinner && Number(winnerVal) === Number(teamBId);

        const tdA = document.createElement('td');
        const wrapA = document.createElement('span'); wrapA.className = 'teamNameWrap';
        if (isWinA) {
          const icoA = document.createElement('span'); icoA.className = 'winIcon'; icoA.textContent = 'ðŸ†'; icoA.setAttribute('aria-label','Sieger');
          const txtA = document.createElement('span'); txtA.className = 'winnerText'; txtA.textContent = teamAName;
          wrapA.append(icoA, txtA);
        } else {
          const txtA = document.createElement('span'); txtA.className = 'loserText'; txtA.textContent = teamAName;
          wrapA.append(txtA);
        }
        tdA.replaceChildren(wrapA);

        const tdB = document.createElement('td');
        const wrapB = document.createElement('span'); wrapB.className = 'teamNameWrap';
        if (isWinB) {
          const icoB = document.createElement('span'); icoB.className = 'winIcon'; icoB.textContent = 'ðŸ†'; icoB.setAttribute('aria-label','Sieger');
          const txtB = document.createElement('span'); txtB.className = 'winnerText'; txtB.textContent = teamBName;
          wrapB.append(icoB, txtB);
        } else {
          const txtB = document.createElement('span'); txtB.className = 'loserText'; txtB.textContent = teamBName;
          wrapB.append(txtB);
        }
        tdB.replaceChildren(wrapB);

        const tdWinner = document.createElement('td');
        if (hasWinner) {
          tdWinner.textContent = Number(winnerVal) === Number(teamAId) ? teamAName : teamBName;
        } else {
          tdWinner.textContent = '';
        }

        const tdAct = document.createElement('td'); tdAct.className = 'row';
        const grpCls = groupClass(groupName);

        const btnWinA = document.createElement('button');
        btnWinA.className = 'btn ' + grpCls; btnWinA.type = 'button'; btnWinA.dataset.action = 'winA';
        btnWinA.dataset.id = String(id); if (teamAId != null) btnWinA.dataset.team = String(teamAId);
        btnWinA.textContent = 'Sieger: Team A';

        const btnWinB = document.createElement('button');
        btnWinB.className = 'btn ' + grpCls; btnWinB.type = 'button'; btnWinB.dataset.action = 'winB';
        btnWinB.dataset.id = String(id); if (teamBId != null) btnWinB.dataset.team = String(teamBId);
        btnWinB.textContent = 'Sieger: Team B';

        tdAct.append(btnWinA, btnWinB);

        tr.append(tdId, tdGroup, tdRound, tdField, tdTime, tdA, tdB, tdWinner, tdAct);
        tbody.appendChild(tr);
      });

      // Delegation: Sieger setzen
      tbody.querySelectorAll('button[data-action]').forEach(btn => {
        btn.addEventListener('click', async (e) => {
          const id = Number(e.currentTarget.dataset.id);
          const winnerId = Number(e.currentTarget.dataset.team);
          if (!Number.isFinite(id) || !Number.isFinite(winnerId)) {
            alert('UngÃ¼ltige Match-/Team-ID.');
            return;
          }
          try { await setWinner(id, winnerId); await refreshMatches(); }
          catch (err) { alert('Fehler beim Setzen des Siegers: ' + err.message); }
        });
      });
    }

    async function refreshMatches(){
      try { MATCHES = await loadMatches(); renderMatches(); }
      catch(e){ showMsg('#nextMsg', 'Fehler: '+e.message, true); }
    }
  </script>

  <!-- ===== History-View (Winner-Icon markiert) ===== -->
  <script>
    function renderHistory() {
      const tbody = document.querySelector('#historyTable tbody');
      if (!tbody) return;
      tbody.innerHTML = '';

      const items = Array.isArray(HISTORY.items) ? HISTORY.items : [];
      if (!items.length) {
        const tr = document.createElement('tr');
        const td = document.createElement('td'); td.colSpan = 7; td.textContent = 'Keine History vorhanden.';
        tr.appendChild(td); tbody.appendChild(tr); return;
      }

      items.forEach((h, idx) => {
        const tr = document.createElement('tr');

        const tdIdx   = document.createElement('td'); tdIdx.textContent = String(idx + 1);
        const tdGR    = document.createElement('td'); tdGR.textContent = `${h.groupName ?? ''} Â· R${h.round ?? ''}`;
        const tdField = document.createElement('td'); tdField.textContent = h.field ?? '';

        // Team A (mit Icon, wenn Sieger)
        const tdA = document.createElement('td');
        const wrapA = document.createElement('span'); wrapA.className = 'teamNameWrap';
        const aIsWinner = Number(h.winner) === Number(h.teamA);
        if (aIsWinner) {
          const icoA = document.createElement('span'); icoA.className = 'winIcon'; icoA.textContent = 'ðŸ†'; icoA.setAttribute('aria-label','Sieger');
          const txtA = document.createElement('span'); txtA.className = 'winnerText'; txtA.textContent = h.teamA_name ?? h.teamA ?? '';
          wrapA.append(icoA, txtA);
        } else {
          const txtA = document.createElement('span'); txtA.className = 'loserText'; txtA.textContent = h.teamA_name ?? h.teamA ?? '';
          wrapA.append(txtA);
        }
        tdA.replaceChildren(wrapA);

        // Team B (mit Icon, wenn Sieger)
        const tdB = document.createElement('td');
        const wrapB = document.createElement('span'); wrapB.className = 'teamNameWrap';
        const bIsWinner = Number(h.winner) === Number(h.teamB);
        if (bIsWinner) {
          const icoB = document.createElement('span'); icoB.className = 'winIcon'; icoB.textContent = 'ðŸ†'; icoB.setAttribute('aria-label','Sieger');
          const txtB = document.createElement('span'); txtB.className = 'winnerText'; txtB.textContent = h.teamB_name ?? h.teamB ?? '';
          wrapB.append(icoB, txtB);
        } else {
          const txtB = document.createElement('span'); txtB.className = 'loserText'; txtB.textContent = h.teamB_name ?? h.teamB ?? '';
          wrapB.append(txtB);
        }
        tdB.replaceChildren(wrapB);

        // Sieger-Spalte (nur Textzusammenfassung)
        const tdWin   = document.createElement('td');
        tdWin.textContent =
          aIsWinner ? (h.teamA_name ?? h.teamA ?? '') :
          bIsWinner ? (h.teamB_name ?? h.teamB ?? '') : 'â€“';

        // Aktionen (Sieger setzen)
        const tdAct   = document.createElement('td'); tdAct.className = 'row';
        const btnA = document.createElement('button');
        btnA.className = 'btn ' + groupClass(h.groupName); btnA.type='button';
        btnA.textContent = 'Sieger: Team A'; btnA.addEventListener('click', async () => {
          try {
            await setHistoryWinner(h.id, h.teamA);
            showMsg('#histMsg', `#${idx+1}: Sieger â†’ Team A gespeichert.`);
            await loadHistoryUI();   // Ansicht neu aufbauen -> Icon wechselt
          } catch (e) { showMsg('#histMsg', 'Fehler: ' + e.message, true); }
        });

        const btnB = document.createElement('button');
        btnB.className = 'btn ' + groupClass(h.groupName); btnB.type='button';
        btnB.textContent = 'Sieger: Team B'; btnB.addEventListener('click', async () => {
          try {
            await setHistoryWinner(h.id, h.teamB);
            showMsg('#histMsg', `#${idx+1}: Sieger â†’ Team B gespeichert.`);
            await loadHistoryUI();   // Ansicht neu aufbauen -> Icon wechselt
          } catch (e) { showMsg('#histMsg', 'Fehler: ' + e.message, true); }
        });

        tdAct.append(btnA, btnB);

        tr.append(tdIdx, tdGR, tdField, tdA, tdB, tdWin, tdAct);
        tbody.appendChild(tr);
      });
    }

    async function loadHistoryUI() {
      const g = (document.getElementById('hist-group').value || '').trim().toUpperCase();
      try {
        HISTORY = await loadHistoryLatest(g);
        renderHistory();
      } catch (e) {
        showMsg('#histMsg', 'History-Fehler: ' + e.message, true);
      }
    }
  </script>

  <!-- ===== Next Round / Socket / UI ===== -->
  <script>
    function computeNextRoundPayloadFromTop3(){
      if (!Array.isArray(MATCHES)) throw new Error('Keine Spieldaten geladen.');
      const top3 = MATCHES.slice(0,3);
      if (top3.length !== 3) throw new Error('Mindestens 3 Spiele erforderlich.');
      const groupName = String(top3[0]?.groupName || '').trim();
      if (!groupName) throw new Error('Gruppe der obersten Spiele nicht ermittelbar.');
      const allSame = top3.every(m => String(m?.groupName || '').trim() === groupName);
      if (!allSame) throw new Error('Die obersten 3 Spiele gehÃ¶ren nicht zur gleichen Gruppe.');
      const results = top3.map(m => {
        const teamAId = Number(m?.teamA_id);
        const teamBId = Number(m?.teamB_id);
        const wRaw = m?.winner;
        if (wRaw == null) throw new Error('FÃ¼r Spiel ' + (m?.id || '?') + ' ist kein Sieger gesetzt.');
        const winnerId = Number(wRaw);
        if (!Number.isFinite(winnerId)) throw new Error('UngÃ¼ltiger Siegerwert bei Spiel ' + (m?.id || '?'));
        const loserId = (Number.isFinite(teamAId) && winnerId === teamAId) ? teamBId
                      : (Number.isFinite(teamBId) && winnerId === teamBId) ? teamAId
                      : NaN;
        if (!Number.isFinite(loserId)) throw new Error('Sieger gehÃ¶rt nicht zu Team A/B bei Spiel ' + (m?.id || '?'));
        return { winnerId, loserId, field: Number(m?.field) || undefined };
      });
      return { groupName, results };
    }

    function initSocket(){
      const base = window.location.origin;
      const s = window.io ? window.io(base, {
        path:'/socket.io',
        transports:['websocket','polling'],
        reconnectionAttempts:10,
        timeout:10000
      }) : null;
      if (!s) return;

      s.on('connect', () => console.log('Admin socket connected'));
      s.on('disconnect', (reason) => console.warn('Admin socket disconnected:', reason));
      s.on('connect_error', (err) => console.error('Admin socket connect_error:', err));

      const reloadMatches = () => refreshMatches();
      s.on('resultUpdate', reloadMatches);
      s.on('results:updated', reloadMatches);
      s.on('group:started',   reloadMatches);
      s.on('round:advanced',  reloadMatches);
      s.on('round:rebuilt',   reloadMatches);
      s.on('history:archived', () => {}); // optional nutzen
      s.on('history:updated',  () => {}); // optional nutzen
      s.on('matches:reset',   reloadMatches);
      s.on('schedule:recalculated', reloadMatches);
    }

    function wireUI(){
      // Teams
      document.getElementById('btnLoadTeams')?.addEventListener('click', refreshTeams);
      document.getElementById('btnDeleteAllTeams')?.addEventListener('click', async () => {
        if (!confirm('Wirklich ALLE Teams lÃ¶schen?')) return;
        try { await deleteAllTeams(); showMsg('#teamsMsg', 'Alle Teams wurden gelÃ¶scht.'); await refreshTeams(); }
        catch (err) { showMsg('#teamsMsg', 'Fehler beim LÃ¶schen aller Teams: ' + err.message, true); }
      });
      document.getElementById('btnAddTeam')?.addEventListener('click', async () => {
        const name = (document.getElementById('teamName').value || '').trim();
        const groupName = document.getElementById('teamGroup').value;
        if (!name) { showMsg('#teamsMsg','Bitte Teamname eingeben.', true); return; }
        try { await addTeam(name, groupName); showMsg('#teamsMsg','Team hinzugefÃ¼gt.'); document.getElementById('teamName').value=''; await refreshTeams(); }
        catch (err) { showMsg('#teamsMsg', 'Fehler: ' + err.message, true); }
      });
      document.getElementById('btnImportTeams')?.addEventListener('click', async () => {
        const inp = document.getElementById('teamsFile');
        if (!inp || !inp.files || !inp.files[0]) { showMsg('#importMsg','Bitte CSV/JSON Datei auswÃ¤hlen.', true); return; }
        try {
          const text = await inp.files[0].text(); let entries = [];
          if (inp.files[0].name.toLowerCase().endsWith('.json')) {
            const obj = JSON.parse(text); entries = Array.isArray(obj) ? obj : (Array.isArray(obj.teams) ? obj.teams : []);
          } else {
            entries = text.split(/\r?\n/).map(l => l.trim()).filter(Boolean).map(l => {
              const [name, groupName] = l.split(',').map(x => x?.trim());
              return { name, groupName };
            });
          }
          let ok=0, fail=0;
          for (const e of entries) {
            const n = (e.name || '').trim();
            const g = e.groupName ? String(e.groupName).trim().toUpperCase() : null;
            if (!n) { fail++; continue; }
            try { await addTeam(n, g); ok++; } catch { fail++; }
          }
          await refreshTeams();
          showMsg('#importMsg', `Import: ${ok}/${entries.length} erfolgreich, ${fail} fehlgeschlagen.`);
        } catch (err) { showMsg('#importMsg','Importâ€‘Fehler: ' + err.message, true); }
      });

      // Matches
      document.getElementById('btnLoadMatches')?.addEventListener('click', refreshMatches);
      document.getElementById('btnReset')?.addEventListener('click', async () => {
        if (!confirm('Spielplan wirklich zurÃ¼cksetzen?')) return;
        try { await resetMatches(); await refreshMatches(); }
        catch (err) { alert('Fehler beim Reset: ' + err.message); }
      });

      document.getElementById('btnStartA')?.addEventListener('click', async () => { try { await startGroup('A'); await refreshMatches(); } catch (err) { alert('Fehler: ' + err.message); } });
      document.getElementById('btnStartB')?.addEventListener('click', async () => { try { await startGroup('B'); await refreshMatches(); } catch (err) { alert('Fehler: ' + err.message); } });
      document.getElementById('btnStartC')?.addEventListener('click', async () => { try { await startGroup('C'); await refreshMatches(); } catch (err) { alert('Fehler: ' + err.message); } });

      document.getElementById('btnNextRound')?.addEventListener('click', async () => {
        try { const p = computeNextRoundPayloadFromTop3(); await nextRoundReq(p.groupName, p.results); showMsg('#nextMsg', 'NÃ¤chste Runde fÃ¼r Gruppe ' + p.groupName + ' generiert.'); await refreshMatches(); }
        catch (err) { showMsg('#nextMsg','Fehler: ' + err.message, true); }
      });

      // History
      document.getElementById('btnLoadHistory')?.addEventListener('click', loadHistoryUI);
      document.getElementById('btnApplyHistory')?.addEventListener('click', async () => {
        const g = (document.getElementById('hist-group').value || '').trim().toUpperCase();
        try {
          await rebuildCurrentRound(g);
          await refreshMatches();
          showMsg('#histMsg', 'Aktueller 3erâ€‘Block im Hauptâ€‘View aktualisiert.');
        } catch (e) {
          showMsg('#histMsg', 'Rebuild-Fehler: ' + e.message, true);
        }
      });

      // Zeitplan
      wireScheduleUI();
      fillScheduleUI();
    }

    document.addEventListener('DOMContentLoaded', () => {
      initHeader();   // Logo + QR
      wireUI();       // Buttons
      initSocket();   // Live-Updates
      refreshTeams();
      refreshMatches();
      loadHistoryUI();
      setInterval(refreshMatches, 15000); // Fallback Polling
    });
  </script>
</body>
</html>
