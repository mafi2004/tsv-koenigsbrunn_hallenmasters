
<!doctype html>
<html lang="de">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Admin â€“ 3. KÃ¶nigsbrunner Mini-FuÃŸball Hallenmasters</title>

  <style>
    :root {
      --bg: #0f172a; --fg: #e5e7eb; --muted: #9ca3af; --accent: #22c55e; --danger: #ef4444;
      --card: #111827; --border: #1f2937;

      /* Gruppenfarben */
      --grpA-bg: #0b1b3a; --grpA-fg: #bfdbfe; --grpA-br: #1d4ed8;
      --grpB-bg: #2b0c0c; --grpB-fg: #fecaca; --grpB-br: #7f1d1d;
      --grpC-bg: #052e1b; --grpC-fg: #86efac; --grpC-br: #166534;
      --grpD-bg: #1f2937; --grpD-fg: #fde68a; --grpD-br: #f59e0b;
      --grpE-bg: #1f2937; --grpE-fg: #ddd6fe; --grpE-br: #8b5cf6;
      --grpF-bg: #0b3640; --grpF-fg: #c0fafe; --grpF-br: #06b6d4;

      --ok:#22c55e; --warn:#f59e0b; --err:#ef4444;

      /* Hinweise */
      --hint-bg:#0b1020; --hint-br:#2a3b57; --hint-fg:#cbd5e1;
    }

    html, body { height:100%; }
    body { margin:0; background:var(--bg); color:var(--fg);
           font-family:system-ui,-apple-system, Segoe UI, Roboto, Ubuntu, Arial; }

    header { position: sticky; top: 0; z-index: 8; background: var(--card); border-bottom: 1px solid var(--border); }
    header .bar { display:flex; align-items:center; justify-content:space-between; padding: .75rem 1rem; gap: 1rem; }
    .leftWrap { display:flex; align-items:center; gap:1rem; flex-wrap:wrap; min-height:56px; }
    .titleWrap { display:flex; align-items:center; gap:.75rem; }
    .clubLogo { width:56px; height:56px; object-fit:contain; border-radius:6px; background:#0b1020; border:1px solid var(--border); }
    header h1 { margin:0; font-size:1.25rem; }
    .viewerLink { color: var(--muted); text-decoration: none; }

    main { padding:1rem; max-width:1200px; margin:0 auto; }
    section { margin-bottom:2rem; background:var(--card); border:1px solid var(--border); border-radius:8px; }
    section > header { align-items:center; justify-content:space-between; gap:1rem; padding:.75rem 1rem; border-bottom:1px solid var(--border); display:flex; }
    .row { display:flex; flex-wrap:wrap; gap:.75rem; align-items:center; }
    .tableWrap { overflow-x:auto; }

    .btn { cursor:pointer; border:1px solid var(--border); background:#0b1020; color:#e5e7eb; padding:.5rem .75rem; border-radius:6px; font-weight:600; }
    .btn:hover { filter:brightness(1.08); }
    .btn-primary { border-color:#1d4ed8; background:#0b1b3a; color:#bfdbfe; }
    .btn-success { border-color:#166534; background:#052e1b; color:#86efac; }
    .btn-danger  { border-color:#7f1d1d; background:#2b0c0c; color:#fecaca; }
    .btn-muted   { border-color:var(--border); background:#0b1020; color:#9ca3af; }

    .btn.grpA { border-color:var(--grpA-br); background:var(--grpA-bg); color:var(--grpA-fg); }
    .btn.grpB { border-color:var(--grpB-br); background:var(--grpB-bg); color:var(--grpB-fg); }
    .btn.grpC { border-color:var(--grpC-br); background:var(--grpC-bg); color:var(--grpC-fg); }
    .btn.grpD { border-color:var(--grpD-br); background:var(--grpD-bg); color:var(--grpD-fg); }
    .btn.grpE { border-color:var(--grpE-br); background:var(--grpE-bg); color:var(--grpE-fg); }
    .btn.grpF { border-color:var(--grpF-br); background:var(--grpF-bg); color:var(--grpF-fg); }

    .input, select { background:#0b1020; color:var(--fg); border:1px solid var(--border); border-radius:6px; padding:.45rem .6rem; min-height:2rem; }

    table { width:100%; border-collapse:collapse; }
    th, td { border-bottom:1px solid var(--border); padding:.5rem; text-align:left; }
    th { color:#cbd5e1; font-weight:700; background:#0b1020; }
    tr:hover td { background:#0a0f1f; }

    .pill { display:inline-block; padding:.15rem .5rem; border-radius:999px; border:1px solid var(--border); font-size:.8rem; color:#9ca3af; }
    .pill.grpA { color:var(--grpA-fg); border-color:var(--grpA-br); background:var(--grpA-bg); }
    .pill.grpB { color:var(--grpB-fg); border-color:var(--grpB-br); background:var(--grpB-bg); }
    .pill.grpC { color:var(--grpC-fg); border-color:var(--grpC-br); background:var(--grpC-bg); }
    .pill.grpD { color:var(--grpD-fg); border-color:var(--grpD-br); background:var(--grpD-bg); }
    .pill.grpE { color:var(--grpE-fg); border-color:var(--grpE-br); background:var(--grpE-bg); }
    .pill.grpF { color:var(--grpF-fg); border-color:var(--grpF-br); background:var(--grpF-bg); }

    .winIcon { font-size: 1rem; margin-right: .35rem; vertical-align: middle; }
    .winnerText { color: var(--accent); font-weight: 600; }
    .loserText  { color: var(--muted); }
    .teamNameWrap { display:inline-flex; align-items:center; gap:.35rem; }

    .card { background: var(--card); border: 1px solid var(--border); border-radius:8px; padding: 12px; }
    .kvt { font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace; font-size: .9rem; background:#0b1020; color:#cbd5e1; border:1px solid var(--border); border-radius:6px; padding:.5rem; white-space:pre-wrap; }

    /* Teams nebeneinander (Grid) */
    .teams-grid {
      display: grid;
      grid-template-columns: repeat(3, minmax(320px, 1fr));
      gap: 16px;
      align-items: start;
      padding: 1rem;
    }
    @media (max-width: 1100px) { .teams-grid { grid-template-columns: repeat(2, minmax(320px, 1fr)); } }
    @media (max-width: 720px)  { .teams-grid { grid-template-columns: 1fr; } }
    .table-wrap { overflow:auto; }
    .table-wrap thead th { background:#0b1020; }
  </style>
</head>
<body>
  <header>
    <div class="bar">
      <div class="leftWrap">
        <div class="titleWrap">
          <img class="clubLogo" id="clubLogo" alt="Vereinslogo" />
          <div style="display:flex; flex-direction:column; gap:.25rem;">
            <h1>
              Admin â€“ 3. KÃ¶nigsbrunner Mini-FuÃŸball Hallenmasters
              <!-- kleine Kopf-Pill fÃ¼r Label -->
              <span id="adminYearLabelHead" class="pill" style="margin-left:.5rem; display:none;">Jahrgang: â€“</span>
            </h1>
            <div class="logoPath">
              Logo-Pfad: <code id="logoPathText">â€“</code>
              <span id="logoError" class="logoError">Logo konnte nicht geladen werden. Datei unter <code>public/assets/â€¦</code> ablegen und Pfad prÃ¼fen.</span>
            </div>
          </div>
        </div>

        <div class="row" style="gap:.5rem;">
          <label for="qrBase" class="pill" title="Protokoll+Host+Port (z.â€¯B. 192.168.0.25)">Viewerâ€‘Basis:</label>
          <input id="qrBase" type="text" class="input" style="min-width:260px;" placeholder="192.168.0.25" />
          <button id="btnSaveQRBase" type="button" class="btn btn-primary">Speichern</button>
          <a id="viewerLink" class="viewerLink" target="_blank" rel="noopener">Viewer Ã¶ffnen</a>
        </div>
      </div>

      <div id="headerQR" style="display:flex; flex-direction:column; align-items:flex-end;">
        <div class="container">
          <img src="" id="qr-img" alt="QR-Code zum Viewer">
        </div>
      </div>
    </div>
  </header>

  <main>
    <!-- Teams -->
    <section id="teamsSection">
      <header>
        <h2>
          Teams
          <!-- groÃŸe Pill hinter â€žTeamsâ€œ -->
          <span id="adminYearLabel" class="pill" style="margin-left:.5rem; display:none;">Jahrgang: â€“</span>
        </h2>
        <div class="row">
          <button id="btnLoadTeams" type="button" class="btn btn-muted">Teams laden</button>
          <button id="btnDeleteAllTeams" type="button" class="btn btn-danger">Alle Teams lÃ¶schen</button>
        </div>
      </header>

      <div class="teams-grid" id="teamsGrid"></div>

      <div class="row" style="padding:1rem">
        <!-- Manuelle Team-Erfassung wie gehabt -->
        <div class="row" style="flex:1 1 100%">
          <input id="teamName" class="input" placeholder="Teamname" />
          <select id="teamGroup" class="input">
            <option value="A">Gruppe A</option>
            <option value="B">Gruppe B</option>
            <option value="C">Gruppe C</option>
          </select>
          <button id="btnAddTeam" type="button" class="btn btn-success">HinzufÃ¼gen</button>
          <span id="teamsMsg" class="pill" style="display:none"></span>
        </div>

        <!-- NEU: Jahrgangs-Bezeichner konfigurieren -->
        <div class="row" style="flex:1 1 100%">
          <label for="yearLabelInput" class="pill" title="Bezeichner fÃ¼r die Turnierdatei und Anzeige im Viewer">Jahrgangsâ€‘Label:</label>
          <input id="yearLabelInput" type="text" class="input" style="min-width:260px;" placeholder="z.â€¯B. U10 Samstag" />
          <button id="btnSaveYearLabel" type="button" class="btn btn-primary" title="Label speichern (optional serverseitig)">Speichern</button>
          <span id="yearLabelMsg" class="pill" style="display:none"></span>
        </div>

        <!-- Turnierdatei Import/Export (Label + Zeitplan + Teams) -->
        <div class="row" style="flex:1 1 100%">
          <input id="tournamentFile" type="file" accept=".json" class="input" />
          <button id="btnImportTournament" type="button" class="btn btn-primary" title="Label + Zeitplan + Teams importieren">Turnierdatei importieren</button>
          <button id="btnExportTournament" type="button" class="btn btn-muted"  title="Label + Zeitplan + Teams exportieren">Turnierdatei exportieren</button>
          <span id="tournamentMsg" class="pill" style="display:none"></span>
        </div>
      </div>
    </section>

    <!-- Matches (Haupt-View) -->
    <section id="matchesSection">
      <header>
        <h2>Spiele</h2>
        <div class="row">
          <button id="btnLoadMatches" type="button" class="btn btn-muted">Spiele laden</button>
          <button id="btnStartA" type="button" class="btn grpA">Gruppe A starten</button>
          <button id="btnStartB" type="button" class="btn grpB">Gruppe B starten</button>
          <button id="btnStartC" type="button" class="btn grpC">Gruppe C starten</button>
          <button id="btnNextRound" type="button" class="btn btn-primary">NÃ¤chste Runde (oberste 3)</button>
          <span id="nextMsg" class="pill" style="display:none"></span>
          <button id="btnReset"  type="button" class="btn btn-danger">Spielplan zurÃ¼cksetzen</button>
          <button id="btnReseedGroups" type="button" class="btn btn-primary">Gruppen neu zusammenstellen (nach 3 Runden)</button>
          <span id="reseedMsg" class="pill" style="display:none"></span>
        </div>
      </header>

      <div class="row" style="padding:1rem">
        <div class="card" style="flex:1 1 100%">
          <h3 style="margin:.25rem 0 1rem; color:#cbd5e1;">Zeitmanagement (global)</h3>
          <div class="tm-row">
            <label for="sched-time">Start:</label>
            <input id="sched-time" type="time" class="input" step="60" />
            <label for="sched-dur">Dauer (min):</label>
            <input id="sched-dur" type="number" min="1" step="1" value="10" class="input" style="width:90px" />
            <label for="sched-break">Pause (min):</label>
            <input id="sched-break" type="number" min="0" step="1" value="2" class="input" style="width:90px" />
            <button id="sched-save" class="btn btn-primary">Speichern</button>
            <span id="timeMsg" class="pill" style="display:none; margin-left:auto;"></span>
          </div>
          <div style="margin-top:.5rem; color:#9ca3af; font-size:.85rem;">
            Raster: alphabetisch pro Slot (A â†’ B â†’ C). Runde&nbsp;2 von A bezieht sich zeitlich auf vorheriges C. Slot = <em>Dauer + Pause</em>.
          </div>
        </div>
      </div>

      <div class="tableWrap" style="padding:1rem">
        <table id="matchesTable">
          <thead>
            <tr>
              <th>ID</th>
              <th>Gruppe</th>
              <th>Runde</th>
              <th>Feld</th>
              <th>Zeit</th>
              <th>Team A</th>
              <th>Team B</th>
              <th>Sieger</th>
              <th>Aktion</th>
            </tr>
          </thead>
          <tbody></tbody>
        </table>
      </div>
    </section>

    <!-- Historie -->
    <section id="historySection">
      <header>
        <h2>Historie (letzte gespielte Runde)</h2>
        <div class="row">
          <label for="hist-group" class="pill">Gruppe:</label>
          <select id="hist-group" class="input">
            <option value="A">A</option><option value="B">B</option><option value="C">C</option>
            <option value="D">D</option><option value="E">E</option><option value="F">F</option>
          </select>
          <button id="btnLoadHistory" type="button" class="btn btn-muted">History laden</button>
          <button id="btnApplyHistory" type="button" class="btn btn-primary" title="Korrekturen anwenden und aktuellen 3er-Block im Haupt-View aktualisieren">Ãœbernehmen & Hauptâ€‘View aktualisieren</button>
          <span id="histMsg" class="pill" style="display:none"></span>
        </div>
      </header>

      <div class="tableWrap" style="padding:1rem">
        <table id="historyTable">
          <thead>
            <tr>
              <th>#</th>
              <th>GruppeÂ·Runde</th>
              <th>Feld</th>
              <th>Team A</th>
              <th>Team B</th>
              <th>Sieger</th>
              <th>Aktion</th>
            </tr>
          </thead>
          <tbody></tbody>
        </table>
      </div>
    </section>

    <!-- Recovery & Snapshots (Dropdown-only) -->
    <section id="recoverySection">
      <header>
        <h2>Recovery & Snapshots</h2>
        <div class="row">
          <button id="btnMakeSnapshot" type="button" class="btn btn-success" title="Aktuellen Zustand als Snapshot sichern">Snapshot jetzt erstellen</button>
          <button id="btnRecoverLatest" type="button" class="btn btn-danger" title="Neuesten Snapshot wiederherstellen">Neuesten Snapshot wiederherstellen</button>

          <label for="snapshotSelect" class="pill">Snapshot wÃ¤hlen:</label>
          <select id="snapshotSelect" class="input" style="min-width:320px;"></select>
          <button id="btnRecoverSelected" type="button" class="btn btn-primary">GewÃ¤hlten Snapshot wiederherstellen</button>

          <label for="opsSelect" class="pill" style="margin-left:.5rem;">Letzte Adminâ€‘Operation:</label>
          <select id="opsSelect" class="input" style="min-width:320px;"></select>
          <button id="btnShowOp" type="button" class="btn btn-muted">Details anzeigen</button>

          <span id="recMsg" class="pill" style="display:none;"></span>
        </div>
      </header>

      <div class="row" style="padding:1rem">
        <div class="card" style="flex:1 1 100%">
          <h3 style="margin:.25rem 0 1rem; color:#cbd5e1;">AusgewÃ¤hlte Operation (Details)</h3>
          <div id="opDetails" class="kvt" aria-live="polite">â€“</div>
        </div>
      </div>
    </section>
  </main>

  <!-- Skripte -->
  <script src="/socket.io/socket.io.js"></script>
  <script src="/qr_script.js"></script>

  <!-- Logo -->
  <script>
    const LOGO_PATH = '/assets/Fussballwappen_logo.png';
    const cacheBust = () => `?_v=${Date.now()}`;
    function setLogo(){
      const img = document.getElementById('clubLogo');
      const pathEl = document.getElementById('logoPathText');
      const errEl  = document.getElementById('logoError');
      if (!img || !pathEl) return;
      const url = LOGO_PATH + cacheBust();
      pathEl.textContent = LOGO_PATH;
      img.onload = () => { if (errEl) errEl.style.display = 'none'; };
      img.onerror = () => { if (errEl) errEl.style.display = 'inline-flex'; };
      img.src = url;
    }
    function initHeader(){ setLogo(); }
  </script>

  <!-- APIs / State / Helpers -->
  <script>
    const API_BASE = window.location.origin + '/api';

    async function safeFetch(path, init) {
      const url = API_BASE + path;
      const res = await fetch(url, init);
      if (!res.ok) {
        let text = ''; try { text = await res.text(); } catch {}
        throw new Error('HTTP ' + res.status + ' ' + res.statusText + (text ? ': ' + text : ''));
      }
      return res.json();
    }

    /* APIs */
    const apiTeamsList      = () => safeFetch('/teams', { method:'GET' });
    const apiTeamsDeleteAll = () => safeFetch('/teams', { method:'DELETE' });
    const apiTeamAdd        = (name, groupName) => safeFetch('/teams', { method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify({ name, groupName }) });
    const apiTeamDelete     = (id) => safeFetch('/teams/' + encodeURIComponent(id), { method:'DELETE' });

    const apiMatchesList    = () => safeFetch('/matches', { method:'GET' });
    const apiGroupStart     = async (group) => {
      const schedule = getSchedule();
      if (!schedule) throw new Error('Kein gÃ¼ltiger Zeitplan konfiguriert.');
      return safeFetch('/matches/start/' + encodeURIComponent(group), {
        method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify({ schedule })
      });
    };
    const apiMatchesReset   = () => safeFetch('/matches/reset', { method:'DELETE' });

    const apiWinnerSet      = (matchId, winnerTeamId) => safeFetch('/results/winner', { method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify({ matchId, winner: winnerTeamId }) });

    const apiNextRound      = async (groupName, results) => {
      const schedule = getSchedule();
      if (!schedule) throw new Error('Kein gÃ¼ltiger Zeitplan konfiguriert.');
      return safeFetch('/funino/nextRound', {
        method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify({ groupName, results, schedule })
      });
    };

    const apiScheduleRecalc = (schedule) =>
      safeFetch('/schedule/recalculate', { method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify({ schedule }) });

    const apiReseedGroups = (schedule) =>
      safeFetch('/funino/reseedGroups', { method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify({ schedule }) });

    const apiHistoryLatest     = (group) => safeFetch('/history/latest/' + encodeURIComponent(group), { method:'GET' });
    const apiHistorySetWinner  = (historyId, winner) => safeFetch('/history/' + encodeURIComponent(historyId) + '/winner', {
      method:'PATCH', headers:{'Content-Type':'application/json'}, body: JSON.stringify({ winner })
    });
    const apiRebuildCurrRound  = (group) => safeFetch('/funino/rebuildCurrentRound', {
      method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify({ groupName: group })
    });

    const apiOpsList       = (limit=200) => safeFetch('/adminOps/ops?limit=' + encodeURIComponent(limit), { method:'GET' });
    const apiSnapList      = () => safeFetch('/adminOps/snapshots', { method:'GET' });
    const apiSnapCreate    = () => safeFetch('/adminOps/snapshot', { method:'POST' });
    const apiRecoverLatest = () => safeFetch('/adminOps/recover', { method:'POST' });
    const apiRecoverById   = (id) => safeFetch('/adminOps/recover/' + encodeURIComponent(id), { method:'POST' });

    /* NEU: Meta-APIs (Label + Zeitplan serverseitig speichern/lesen) */
    const apiMetaGet = () => safeFetch('/meta', { method:'GET' });
    const apiMetaSet = (yearLabel, schedule) =>
      safeFetch('/meta', { method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify({ yearLabel, schedule }) });

    /* Aliases */
    const loadTeams      = apiTeamsList;
    const deleteAllTeams = apiTeamsDeleteAll;
    const addTeam        = apiTeamAdd;
    const deleteTeam     = apiTeamDelete;

    const loadMatches    = apiMatchesList;
    const startGroup     = apiGroupStart;
    const resetMatches   = apiMatchesReset;

    const setWinner      = apiWinnerSet;
    const nextRoundReq   = apiNextRound;

    const loadHistoryLatest = apiHistoryLatest;
    const setHistoryWinner  = apiHistorySetWinner;
    const rebuildCurrentRound = apiRebuildCurrRound;

    const loadOps        = apiOpsList;
    const loadSnapshots  = apiSnapList;
    const makeSnapshot   = apiSnapCreate;
    const recoverLatest  = apiRecoverLatest;
    const recoverById    = apiRecoverById;

    /* State */
    let TEAMS = [];
    let MATCHES = [];
    let HISTORY = { groupName:null, round:null, batchId:null, items:[] };
    let SNAPSHOTS = [];
    let OPS = [];
    let YEAR_LABEL = null;

    /* Helpers */
    function groupClass(g){
      const x = String(g || '').trim().toUpperCase();
      switch (x) { case 'A':return 'grpA'; case 'B':return 'grpB'; case 'C':return 'grpC'; case 'D':return 'grpD'; case 'E':return 'grpE'; case 'F':return 'grpF'; default:return ''; }
    }
    function showMsg(selectorOrEl, text, isError){
      const el = typeof selectorOrEl==='string' ? document.querySelector(selectorOrEl) : selectorOrEl;
      if(!el) return; el.textContent = text; el.style.display='inline-block';
      el.style.borderColor = isError ? 'var(--danger)' : 'var(--accent)';
      el.style.color = isError ? '#fecaca' : '#86efac';
      clearTimeout(el._t); el._t = setTimeout(() => { el.style.display='none'; }, 3500);
    }
    function fmtTs(ts){ try { return new Date(ts).toLocaleString(); } catch { return ts; } }
    function setAdminYearLabel(label){
      YEAR_LABEL = (label ?? '').trim() || null;
      const text = YEAR_LABEL ? ('Jahrgang: ' + YEAR_LABEL) : 'Jahrgang: â€“';
      const el = document.getElementById('adminYearLabel');
      const el2 = document.getElementById('adminYearLabelHead');
      if (el)  { el.style.display='inline-block';  el.textContent = text; }
      if (el2) { el2.style.display='inline-block'; el2.textContent = text; }
      // zusÃ¤tzlich: Feld befÃ¼llen, falls nÃ¶tig
      const fld = document.getElementById('yearLabelInput');
      if (fld && fld.value.trim() !== (YEAR_LABEL ?? '')) {
        fld.value = YEAR_LABEL ?? '';
      }
    }
  </script>

  <!-- Zeitmanagement -->
  <script>
    const SCHED_KEY = 'admin.schedule.v2';
    function loadSchedule(){ try { return JSON.parse(localStorage.getItem(SCHED_KEY) || 'null'); } catch { return null; } }
    function saveSchedule(cfg){ localStorage.setItem(SCHED_KEY, JSON.stringify(cfg)); }
    function getSchedule(){
      const s = loadSchedule();
      if(!s) return null;
      if(!/^\d{2}:\d{2}$/.test(s.timeHHMM)) return null;
      if(!Number.isFinite(s.dur) || s.dur <= 0) return null;
      if(!Number.isFinite(s.brk) || s.brk < 0) return null;
      return s;
    }
    function fillScheduleUI(){
      const cfg = loadSchedule() || {};
      const time = document.getElementById('sched-time');
      const dur  = document.getElementById('sched-dur');
      const brk  = document.getElementById('sched-break');
      if (time && cfg.timeHHMM) time.value = cfg.timeHHMM;
      if (dur  && Number.isFinite(cfg.dur)) dur.value = cfg.dur;
      if (brk  && Number.isFinite(cfg.brk)) brk.value = cfg.brk;
    }
    function wireScheduleUI(){
      const btn = document.getElementById('sched-save');
      btn && btn.addEventListener('click', async () => {
        const timeHHMM = document.getElementById('sched-time').value;
        const dur = Number(document.getElementById('sched-dur').value);
        const brk = Number(document.getElementById('sched-break').value);
        if (!/^\d{2}:\d{2}$/.test(timeHHMM)) { showMsg('#timeMsg', 'Bitte Startzeit im Format HH:MM setzen.', true); return; }
        if (!Number.isFinite(dur) || dur <= 0) { showMsg('#timeMsg', 'Dauer (min) ungÃ¼ltig.', true); return; }
        if (!Number.isFinite(brk) || brk < 0) { showMsg('#timeMsg', 'Pause (min) ungÃ¼ltig.', true); return; }
        const schedule = { timeHHMM, dur, brk };
        saveSchedule(schedule);
        showMsg('#timeMsg', 'Zeitplan gespeichert. Berechne Zeiten ...');
        try {
          await apiMetaSet(YEAR_LABEL, schedule); // Label + Plan serverseitig sichern (falls Route vorhanden)
          await apiScheduleRecalc(schedule);      // Zeiten neu berechnen
          await refreshMatches();
          showMsg('#timeMsg', 'Zeiten aktualisiert.');
        }
        catch(e) { showMsg('#timeMsg', 'Recalc-Fehler: ' + e.message, true); }
      });
    }
  </script>

  <!-- Teams (Render/Refresh) -->
  <script>
    function buildTeamsGrid(groups){
      const grid = document.getElementById('teamsGrid');
      grid.innerHTML = '';
      const order = ['A','B','C','D','E','F'];
      const groupsOrdered = groups.slice().sort((a,b)=> order.indexOf(a) - order.indexOf(b));
      groupsOrdered.forEach(g => {
        const card = document.createElement('div'); card.className = 'card';
        const badge = document.createElement('span'); badge.className = 'pill ' + groupClass(g);
        badge.textContent = 'Gruppe ' + g; badge.style.marginBottom = '.5rem'; card.appendChild(badge);
        const wrap = document.createElement('div'); wrap.className = 'table-wrap';
        const table = document.createElement('table'); table.id = `teams-table-${g}`;
        const thead = document.createElement('thead'); thead.innerHTML = `
          <tr><th style="width:80px;">ID</th><th>Name</th><th style="width:160px;">Aktion</th></tr>`;
        table.appendChild(thead);
        const tbody = document.createElement('tbody'); tbody.id = `teams-tbody-${g}`; table.appendChild(tbody);
        wrap.appendChild(table); card.appendChild(wrap); grid.appendChild(card);
      });
      document.querySelectorAll('[id^="teams-table-"]').forEach(tbl => {
        tbl.addEventListener('click', async (e) => {
          const btn = e.target.closest('button'); if(!btn) return;
          if(btn.dataset.action === 'delete'){
            try { await deleteTeam(btn.dataset.id); await refreshTeams(); }
            catch (err) { showMsg('#teamsMsg', 'Fehler beim LÃ¶schen: ' + err.message, true); }
          }
        });
      });
    }
    function renderTeams(){
      const groupsSet = new Set(TEAMS.map(t => String(t.groupName || '').trim().toUpperCase()).filter(Boolean));
      const groups = groupsSet.size ? Array.from(groupsSet) : ['A','B','C'];
      buildTeamsGrid(groups);
      groups.forEach(g => { const tbody = document.getElementById(`teams-tbody-${g}`); if (tbody) tbody.innerHTML = ''; });
      TEAMS.forEach(t => {
        const g = String(t.groupName || '').trim().toUpperCase();
        const tbody = document.getElementById(`teams-tbody-${g}`); if (!tbody) return;
        const tr = document.createElement('tr');
        const cls = groupClass(t.groupName); if (cls) tr.classList.add(cls);
        const tdId = document.createElement('td'); tdId.textContent = t.id ?? '';
        const tdName = document.createElement('td'); tdName.textContent = t.name ?? '';
        const tdAction = document.createElement('td');
        const btnDel = document.createElement('button');
        btnDel.className='btn btn-danger'; btnDel.type='button';
        btnDel.dataset.action='delete'; btnDel.dataset.id=String(t.id);
        btnDel.textContent='LÃ¶schen';
        tdAction.appendChild(btnDel);
        tr.appendChild(tdId); tr.appendChild(tdName); tr.appendChild(tdAction);
        tbody.appendChild(tr);
      });
    }
    async function refreshTeams(){ try { TEAMS = await loadTeams(); renderTeams(); } catch(e){ showMsg('#teamsMsg', 'Fehler: '+e.message, true); } }
  </script>

  <!-- Matches -->
  <script>
    function renderMatches(){
      const tbody = document.querySelector('#matchesTable tbody');
      if (!tbody) return; tbody.innerHTML = '';
      if (!Array.isArray(MATCHES)) { showMsg('#nextMsg', 'Spieldaten ungÃ¼ltig (kein Array).', true); return; }
      MATCHES.forEach(m => {
        const tr = document.createElement('tr'); const cls = groupClass(m.groupName); if (cls) tr.classList.add(cls);
        const id=m?.id??'', g=m?.groupName??'', r=m?.round??'', f=m?.field??'';
        const taId=m?.teamA_id??null, tbId=m?.teamB_id??null;
        const taName=m?.teamA ?? (taId!=null?String(taId):''), tbName=m?.teamB ?? (tbId!=null?String(tbId):'');
        const planned=m?.plannedStart??'â€“'; const w=m && typeof m.winner!=='undefined' ? m.winner : null; const hasW = w!==null && w!==undefined;
        const td =(t)=>{ const el=document.createElement('td'); el.textContent=t; return el; };
        const tdGroup=document.createElement('td'); const badge=document.createElement('span'); badge.className='pill '+groupClass(g); badge.textContent=g; tdGroup.appendChild(badge);
        const tdA=document.createElement('td'); const wrapA=document.createElement('span'); wrapA.className='teamNameWrap';
        const winA=hasW && Number(w)===Number(taId); if(winA){ const ico=document.createElement('span'); ico.className='winIcon'; ico.textContent='ðŸ†'; ico.setAttribute('aria-label','Sieger'); const txt=document.createElement('span'); txt.className='winnerText'; txt.textContent=taName; wrapA.append(ico,txt);} else { const txt=document.createElement('span'); txt.className='loserText'; txt.textContent=taName; wrapA.append(txt);} tdA.replaceChildren(wrapA);
        const tdB=document.createElement('td'); const wrapB=document.createElement('span'); wrapB.className='teamNameWrap';
        const winB=hasW && Number(w)===Number(tbId); if(winB){ const ico=document.createElement('span'); ico.className='winIcon'; ico.textContent='ðŸ†'; ico.setAttribute('aria-label','Sieger'); const txt=document.createElement('span'); txt.className='winnerText'; txt.textContent=tbName; wrapB.append(ico,txt);} else { const txt=document.createElement('span'); txt.className='loserText'; txt.textContent=tbName; wrapB.append(txt);} tdB.replaceChildren(wrapB);
        const tdWinner=document.createElement('td'); tdWinner.textContent = hasW ? (Number(w)===Number(taId)?taName:tbName) : '';
        const tdAct=document.createElement('td'); tdAct.className='row';
        const btnA=document.createElement('button'); btnA.className='btn '+groupClass(g); btnA.type='button'; btnA.dataset.action='winA'; btnA.dataset.id=String(id); if(taId!=null) btnA.dataset.team=String(taId); btnA.textContent='Sieger: Team A';
        const btnB=document.createElement('button'); btnB.className='btn '+groupClass(g); btnB.type='button'; btnB.dataset.action='winB'; btnB.dataset.id=String(id); if(tbId!=null) btnB.dataset.team=String(tbId); btnB.textContent='Sieger: Team B';
        tdAct.append(btnA, btnB);
        tr.append(td(id), tdGroup, td(r), td(f), td(planned), tdA, tdB, tdWinner, tdAct);
        tbody.appendChild(tr);
      });
      tbody.querySelectorAll('button[data-action]').forEach(btn => {
        btn.addEventListener('click', async (e) => {
          const id = Number(e.currentTarget.dataset.id);
          const winnerId = Number(e.currentTarget.dataset.team);
          if (!Number.isFinite(id) || !Number.isFinite(winnerId)) { alert('UngÃ¼ltige Match-/Team-ID.'); return; }
          try { await setWinner(id, winnerId); await refreshMatches(); }
          catch (err) { alert('Fehler beim Setzen des Siegers: ' + err.message); }
        });
      });
    }
    async function refreshMatches(){ try { MATCHES = await loadMatches(); renderMatches(); } catch(e){ showMsg('#nextMsg', 'Fehler: '+e.message, true); } }
  </script>

  <!-- History -->
  <script>
    function renderHistory(){
      const tbody = document.querySelector('#historyTable tbody');
      if (!tbody) return; tbody.innerHTML='';
      const items = Array.isArray(HISTORY.items) ? HISTORY.items : [];
      if (!items.length){
        const tr=document.createElement('tr'); const td=document.createElement('td'); td.colSpan=7; td.textContent='Keine History vorhanden.'; tr.appendChild(td); tbody.appendChild(tr); return;
      }
      items.forEach((h, idx) => {
        const tr=document.createElement('tr');
        const td=(t)=>{ const el=document.createElement('td'); el.textContent=t; return el; };
        const tdField = td(h.field ?? '');
        const tdIdx = td(String(idx+1));
        const tdGR  = td(`${h.groupName ?? ''} Â· R${h.round ?? ''}`);
        const tdA=document.createElement('td'); const wrapA=document.createElement('span'); wrapA.className='teamNameWrap';
        const aIsW = Number(h.winner)===Number(h.teamA);
        if (aIsW){ const ico=document.createElement('span'); ico.className='winIcon'; ico.textContent='ðŸ†'; ico.setAttribute('aria-label','Sieger'); const txt=document.createElement('span'); txt.className='winnerText'; txt.textContent=h.teamA_name ?? h.teamA ?? ''; wrapA.append(ico,txt); } else { const txt=document.createElement('span'); txt.className='loserText'; txt.textContent=h.teamA_name ?? h.teamA ?? ''; wrapA.append(txt); }
        tdA.replaceChildren(wrapA);
        const tdB=document.createElement('td'); const wrapB=document.createElement('span'); wrapB.className='teamNameWrap';
        const bIsW = Number(h.winner)===Number(h.teamB);
        if (bIsW){ const ico=document.createElement('span'); ico.className='winIcon'; ico.textContent='ðŸ†'; ico.setAttribute('aria-label','Sieger'); const txt=document.createElement('span'); txt.className='winnerText'; txt.textContent=h.teamB_name ?? h.teamB ?? ''; wrapB.append(ico,txt); } else { const txt=document.createElement('span'); txt.className='loserText'; txt.textContent=h.teamB_name ?? h.teamB ?? ''; wrapB.append(txt); }
        tdB.replaceChildren(wrapB);
        const tdWin = td(aIsW ? (h.teamA_name ?? h.teamA ?? '') : (bIsW ? (h.teamB_name ?? h.teamB ?? '') : 'â€“'));
        const tdAct=document.createElement('td'); tdAct.className='row';
        const btnA=document.createElement('button'); btnA.className='btn '+groupClass(h.groupName); btnA.type='button'; btnA.textContent='Sieger: Team A';
        btnA.addEventListener('click', async () => { try { await setHistoryWinner(h.id, h.teamA); showMsg('#histMsg', `#${idx+1}: Sieger â†’ Team A gespeichert.`); await loadHistoryUI(); } catch(e){ showMsg('#histMsg','Fehler: '+e.message, true);} });
        const btnB=document.createElement('button'); btnB.className='btn '+groupClass(h.groupName); btnB.type='button'; btnB.textContent='Sieger: Team B';
        btnB.addEventListener('click', async () => { try { await setHistoryWinner(h.id, h.teamB); showMsg('#histMsg', `#${idx+1}: Sieger â†’ Team B gespeichert.`); await loadHistoryUI(); } catch(e){ showMsg('#histMsg','Fehler: '+e.message, true);} });
        tdAct.append(btnA, btnB);
        tr.append(tdIdx, tdGR, tdField, tdA, tdB, tdWin, tdAct);
        tbody.appendChild(tr);
      });
    }
    async function loadHistoryUI(){
      const g = (document.getElementById('hist-group').value || '').trim().toUpperCase();
      try { HISTORY = await loadHistoryLatest(g); renderHistory(); }
      catch(e){ showMsg('#histMsg', 'History-Fehler: ' + e.message, true); }
    }

    /* NEW: History leeren */
    function clearHistoryUI(){
      HISTORY = { groupName: (document.getElementById('hist-group')?.value || '').toUpperCase(), round:null, batchId:null, items:[] };
      renderHistory();  
      const el = document.getElementById('histMsg');
      if (el) { el.style.display = 'inline-block'; el.textContent = 'History zurÃ¼ckgesetzt.'; setTimeout(() => el.style.display='none', 2000); }
    }
  </script>

  <!-- Snapshots / Ops (Dropdown-only) -->
  <script>
    function renderSnapshots(){
      const sel = document.getElementById('snapshotSelect'); if (!sel) return;
      sel.innerHTML = '';
      if (!Array.isArray(SNAPSHOTS) || SNAPSHOTS.length===0){
        const opt=document.createElement('option'); opt.value=''; opt.textContent='â€“ keine Snapshots â€“'; sel.appendChild(opt); return;
      }
      const hint=document.createElement('option'); hint.value=''; hint.textContent='Snapshot wÃ¤hlen â€¦'; hint.disabled=true; hint.selected=true; sel.appendChild(hint);
      SNAPSHOTS.forEach(s => { const opt=document.createElement('option'); opt.value=String(s.id); opt.textContent=`#${s.id} Â· ${fmtTs(s.ts)} Â· ${s.path}`; sel.appendChild(opt); });
    }
    function renderOps(){
      const sel = document.getElementById('opsSelect'); const detailsBox=document.getElementById('opDetails'); if(!sel||!detailsBox) return;
      sel.innerHTML=''; detailsBox.textContent='â€“';
      if (!Array.isArray(OPS) || OPS.length===0){
        const opt=document.createElement('option'); opt.value=''; opt.textContent='â€“ keine Operationen â€“'; sel.appendChild(opt); return;
      }
      const hint=document.createElement('option'); hint.value=''; hint.textContent='Operation wÃ¤hlen â€¦'; hint.disabled=true; hint.selected=true; sel.appendChild(hint);
      OPS.slice().reverse().forEach(op => { const opt=document.createElement('option'); opt.value=String(op.id); opt.textContent=`#${op.id} Â· ${op.op} Â· ${fmtTs(op.ts)}`; opt.dataset.payload=op.payload??''; opt.dataset.status=op.status??''; sel.appendChild(opt); });
    }
    async function refreshSnapshots(){ try { SNAPSHOTS = await loadSnapshots(); renderSnapshots(); } catch(e){ showMsg('#recMsg','Snapshots laden fehlgeschlagen: '+e.message, true);} }
    async function refreshOps(){ try { OPS = await loadOps(200); renderOps(); } catch(e){ showMsg('#recMsg','Ops laden fehlgeschlagen: '+e.message, true);} }
  </script>

  <!-- Next Round / Socket / UI -->
  <script>
    function computeNextRoundPayloadFromTop3(){
      if (!Array.isArray(MATCHES)) throw new Error('Keine Spieldaten geladen.');
      const top3 = MATCHES.slice(0,3);
      if (top3.length !== 3) throw new Error('Mindestens 3 Spiele erforderlich.');
      const groupName = String(top3[0]?.groupName || '').trim();
      if (!groupName) throw new Error('Gruppe der obersten Spiele nicht ermittelbar.');
      const allSame = top3.every(m => String(m?.groupName || '').trim() === groupName);
      if (!allSame) throw new Error('Die obersten 3 Spiele gehÃ¶ren nicht zur gleichen Gruppe.');
      const results = top3.map(m => {
        const teamAId = Number(m?.teamA_id);
        const teamBId = Number(m?.teamB_id);
        const wRaw = m?.winner;
        if (wRaw == null) throw new Error('FÃ¼r Spiel ' + (m?.id || '?') + ' ist kein Sieger gesetzt.');
        const winnerId = Number(wRaw);
        if (!Number.isFinite(winnerId)) throw new Error('UngÃ¼ltiger Siegerwert bei Spiel ' + (m?.id || '?'));
        const loserId = (Number.isFinite(teamAId) && winnerId === teamAId) ? teamBId
                      : (Number.isFinite(teamBId) && winnerId === teamBId) ? teamAId
                      : NaN;
        if (!Number.isFinite(loserId)) throw new Error('Sieger gehÃ¶rt nicht zu Team A/B bei Spiel ' + (m?.id || '?'));
        return { winnerId, loserId, field: Number(m?.field) || undefined };
      });
      return { groupName, results };
    }

    function initSocket(){
      const s = window.io ? window.io(window.location.origin, {
        path:'/socket.io', transports:['websocket','polling'], reconnectionAttempts:10, timeout:10000
      }) : null;
      if (!s) return;

      const reloadMatches = () => refreshMatches();
      s.on('resultUpdate', reloadMatches);
      s.on('results:updated', reloadMatches);
      s.on('group:started',   reloadMatches);
      s.on('round:advanced',  reloadMatches);
      s.on('round:rebuilt',   reloadMatches);
      s.on('schedule:recalculated', reloadMatches);

      // ðŸ”´ Plan gelÃ¶scht â†’ History sofort leeren
      s.on('matches:reset', () => {
        reloadMatches();
        clearHistoryUI();
      });

      // ðŸŸ¢ Recovery fertig â†’ Matches & History neu laden
      s.on('snapshot:created', async () => { await refreshSnapshots(); showMsg('#recMsg', 'Snapshot erstellt.'); });
      s.on('recovery:done', async () => {
        await refreshMatches();
        await loadHistoryUI();
        await refreshSnapshots();
        showMsg('#recMsg', 'Wiederherstellung abgeschlossen.');
      });

      // Label live (falls Meta-Route vorhanden)
      s.on('meta:updated', (p) => { setAdminYearLabel(p?.yearLabel ?? YEAR_LABEL); });
    }

    function wireUI(){
      // Teams
      document.getElementById('btnLoadTeams')?.addEventListener('click', refreshTeams);
      document.getElementById('btnDeleteAllTeams')?.addEventListener('click', async () => {
        if (!confirm('Wirklich ALLE Teams lÃ¶schen?')) return;
        try { await deleteAllTeams(); showMsg('#teamsMsg', 'Alle Teams wurden gelÃ¶scht.'); await refreshTeams(); }
        catch (err) { showMsg('#teamsMsg', 'Fehler beim LÃ¶schen aller Teams: ' + err.message, true); }
      });
      document.getElementById('btnAddTeam')?.addEventListener('click', async () => {
        const name = (document.getElementById('teamName').value || '').trim();
        const groupName = document.getElementById('teamGroup').value;
        if (!name) { showMsg('#teamsMsg','Bitte Teamname eingeben.', true); return; }
        try { await addTeam(name, groupName); showMsg('#teamsMsg','Team hinzugefÃ¼gt.'); document.getElementById('teamName').value=''; await refreshTeams(); }
        catch (err) { showMsg('#teamsMsg', 'Fehler: ' + err.message, true); }
      });

      // NEU: Jahrgangs-Label speichern
      document.getElementById('btnSaveYearLabel')?.addEventListener('click', async () => {
        const val = (document.getElementById('yearLabelInput').value || '').trim();
        setAdminYearLabel(val);
        showMsg('#yearLabelMsg', 'Label gespeichert.');
        // optional serverseitig persistieren (ohne Zeitplan-Ã„nderung)
        try { await apiMetaSet(val || null, getSchedule() || null); } catch {}
      });

      // Turnierdatei Import / Export
      document.getElementById('btnImportTournament')?.addEventListener('click', async () => {
        const f = document.getElementById('tournamentFile')?.files?.[0];
        await importTournamentFile(f);
        document.getElementById('tournamentFile').value='';
      });
      document.getElementById('btnExportTournament')?.addEventListener('click', exportTournamentFile);

      // Matches
      document.getElementById('btnLoadMatches')?.addEventListener('click', refreshMatches);
      document.getElementById('btnReset')?.addEventListener('click', async () => {
        if (!confirm('Spielplan wirklich zurÃ¼cksetzen?')) return;
        try {
          await resetMatches();
          await refreshMatches();
          clearHistoryUI();
        } catch (err) { alert('Fehler beim Reset: ' + err.message); }
      });

      document.getElementById('btnStartA')?.addEventListener('click', async () => { try { await startGroup('A'); await refreshMatches(); } catch (err) { alert('Fehler: ' + err.message); } });
      document.getElementById('btnStartB')?.addEventListener('click', async () => { try { await startGroup('B'); await refreshMatches(); } catch (err) { alert('Fehler: ' + err.message); } });
      document.getElementById('btnStartC')?.addEventListener('click', async () => { try { await startGroup('C'); await refreshMatches(); } catch (err) { alert('Fehler: ' + err.message); } });

      document.getElementById('btnNextRound')?.addEventListener('click', async () => {
        try {
          const p = computeNextRoundPayloadFromTop3();
          await nextRoundReq(p.groupName, p.results);
          showMsg('#nextMsg', 'NÃ¤chste Runde fÃ¼r Gruppe ' + p.groupName + ' generiert.');
          await refreshMatches();
        } catch (err) { showMsg('#nextMsg','Fehler: ' + err.message, true); }
      });

      // History
      document.getElementById('btnLoadHistory')?.addEventListener('click', loadHistoryUI);
      document.getElementById('btnApplyHistory')?.addEventListener('click', async () => {
        const g = (document.getElementById('hist-group').value || '').trim().toUpperCase();
        try {
          await rebuildCurrentRound(g);
          await refreshMatches();
          showMsg('#histMsg', 'Aktueller 3erâ€‘Block im Hauptâ€‘View aktualisiert.');
        } catch (e) { showMsg('#histMsg', 'Rebuild-Fehler: ' + e.message, true); }
      });

      // Recovery & Snapshots
      document.getElementById('btnMakeSnapshot')?.addEventListener('click', async () => {
        try { const r = await makeSnapshot(); showMsg('#recMsg', `Snapshot erstellt: ${r.path}`); await refreshSnapshots(); }
        catch (e) { showMsg('#recMsg', 'Snapshot-Fehler: ' + e.message, true); }
      });

      document.getElementById('btnRecoverLatest')?.addEventListener('click', async () => {
        if (!confirm('Neuesten Snapshot wiederherstellen? Dies Ã¼berschreibt den aktuellen Stand.')) return;
        try {
          const r = await recoverLatest();
          showMsg('#recMsg', `Snapshot #${r.snapshotId} wiederhergestellt.`);
          await refreshMatches();
          await loadHistoryUI();
          await refreshSnapshots();
        } catch (e) { showMsg('#recMsg', 'Recovery-Fehler: ' + e.message, true); }
      });

      document.getElementById('btnRecoverSelected')?.addEventListener('click', async () => {
        const sel = document.getElementById('snapshotSelect'); const id = Number(sel?.value);
        if (!Number.isFinite(id)) { showMsg('#recMsg', 'Bitte einen Snapshot wÃ¤hlen.', true); return; }
        if (!confirm(`Snapshot #${id} wiederherstellen?`)) return;
        try {
          await recoverById(id);
          showMsg('#recMsg', `Snapshot #${id} wiederhergestellt.`);
          await refreshMatches();
          await loadHistoryUI();
          await refreshSnapshots();
        } catch (e) { showMsg('#recMsg', 'Recovery-Fehler: ' + e.message, true); }
      });

      // Admin-Op Details
      document.getElementById('opsSelect')?.addEventListener('change', (e) => {
        const sel = e.currentTarget; const opt = sel.options[sel.selectedIndex];
        const detailsBox = document.getElementById('opDetails');
        if (!opt || !opt.value) { detailsBox.textContent = 'â€“'; return; }
        const id = opt.value; const status = opt.dataset.status || '';
        let payloadText = opt.dataset.payload || '';
        try { const obj = JSON.parse(payloadText); payloadText = JSON.stringify(obj, null, 2); } catch {}
        detailsBox.textContent =
`ID: ${id}
Operation: ${opt.textContent}
Status: ${status}

Payload:
${payloadText}`;
      });

      // Zeitplan UI
      wireScheduleUI();
      fillScheduleUI();
    }

    // Turnierdatei Import
    async function importTournamentFile(file){
      if (!file) { showMsg('#tournamentMsg','Bitte Turnierdatei wÃ¤hlen.',true); return; }
      try {
        const text = await file.text();
        const obj = JSON.parse(text);
        if (!obj || typeof obj !== 'object') throw new Error('UngÃ¼ltige JSON-Struktur.');
        const yearLabel = String(obj?.meta?.yearLabel ?? '').trim() || null;
        const s = obj?.meta?.schedule;
        if (!s || !/^\d{2}:\d{2}$/.test(s.timeHHMM) || !Number.isFinite(Number(s.dur)) || Number(s.dur) <= 0 || !Number.isFinite(Number(s.brk)) || Number(s.brk) < 0) {
          throw new Error('Schedule fehlt/ungÃ¼ltig (timeHHMM, dur>0, brk>=0).');
        }
        const teamsArr = Array.isArray(obj?.teams) ? obj.teams : [];

        // Label anzeigen + Feld setzen
        setAdminYearLabel(yearLabel);
        const fld = document.getElementById('yearLabelInput'); if (fld) fld.value = yearLabel ?? '';

        const schedule = { timeHHMM: s.timeHHMM, dur: Number(s.dur), brk: Number(s.brk) };
        saveSchedule(schedule);
        try { await apiMetaSet(yearLabel, schedule); } catch {}
        await apiScheduleRecalc(schedule);

        let added = 0;
        for (const t of teamsArr) {
          const name = String(t?.name ?? '').trim();
          const grp  = String(t?.groupName ?? '').trim().toUpperCase();
          if (!name || !grp) continue;
          try { await addTeam(name, grp); added++; } catch {}
        }

        showMsg('#tournamentMsg', `Turnierdatei importiert. Label: ${yearLabel ?? 'â€“'} | Teams: ${added}/${teamsArr.length}`);
        await refreshTeams();
        await refreshMatches();
      } catch (e) {
        showMsg('#tournamentMsg','Import-Fehler: ' + e.message, true);
      }
    }

    // Turnierdatei Export
    async function exportTournamentFile(){
      try {
        const teams = await loadTeams();
        const schedLocal = loadSchedule();
        let meta = null; try { meta = await apiMetaGet(); } catch {}
        const schedule = {
          timeHHMM: schedLocal?.timeHHMM ?? meta?.schedule?.timeHHMM ?? null,
          dur:      schedLocal?.dur      ?? meta?.schedule?.dur      ?? null,
          brk:      schedLocal?.brk      ?? meta?.schedule?.brk      ?? null
        };
        const fld = document.getElementById('yearLabelInput');
        const labelFromUI = (fld?.value || '').trim() || null;
        const payload = {
          meta: { yearLabel: labelFromUI ?? YEAR_LABEL ?? meta?.yearLabel ?? null, schedule },
          teams: (teams || []).map(t => ({ name: t.name, groupName: t.groupName ?? null }))
        };
        const blob = new Blob([JSON.stringify(payload, null, 2)], { type: 'application/json' });
        const a = document.createElement('a');
        const ts = new Date();
        const YYYY = ts.getFullYear();
        const MM = String(ts.getMonth()+1).padStart(2,'0');
        const DD = String(ts.getDate()).padStart(2,'0');
        const hh = String(ts.getHours()).padStart(2,'0');
        const mm = String(ts.getMinutes()).padStart(2,'0');
        const fn = `tournament_${(payload.meta.yearLabel||'label')}_${YYYY}${MM}${DD}_${hh}${mm}.json`.replace(/\s+/g,'_');
        a.href = URL.createObjectURL(blob);
        a.download = fn;
        a.click();
        URL.revokeObjectURL(a.href);
        showMsg('#tournamentMsg', 'Turnierdatei exportiert: ' + fn);
      } catch (e) {
        showMsg('#tournamentMsg', 'Export-Fehler: ' + e.message, true);
      }
    }

    document.addEventListener('DOMContentLoaded', async () => {
      initHeader();
      wireUI();
      initSocket();

      // Meta beim Start laden (falls Route existiert)
      try {
        const m = await apiMetaGet();
        setAdminYearLabel(m?.yearLabel ?? null);
        const fld = document.getElementById('yearLabelInput'); if (fld) fld.value = (m?.yearLabel ?? '');
        const local = loadSchedule();
        const s = m?.schedule;
        if (!local && s?.timeHHMM && Number.isFinite(Number(s?.dur)) && Number.isFinite(Number(s?.brk))) {
          saveSchedule({ timeHHMM: s.timeHHMM, dur: Number(s.dur), brk: Number(s.brk) });
          fillScheduleUI();
        } else {
          fillScheduleUI();
        }
      } catch {
        fillScheduleUI();
      }

      await refreshTeams();
      await refreshMatches();
      await loadHistoryUI();
      await refreshSnapshots();
      await refreshOps();
      setInterval(refreshMatches, 15000);
    });
  </script>
</body>
</html>
